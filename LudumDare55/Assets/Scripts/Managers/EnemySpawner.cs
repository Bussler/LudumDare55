using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Manage enemy spawning and wave progression.
/// </summary>
public class EnemySpawner : MonoBehaviour
{
    public static EnemySpawner Instance;

    public List<EnemyWave> waves; // List of waves to spawn
    private List<EnemyWave> wavesCopy; // deepcopy of waves to spawn, for internal use.
    public EnemyWave bossWave; // Boss wave to spawn at the end

    [Header("Spawner Attributes")]
    [SerializeField]
    private float waveInterval; // Time between waves (in seconds) // TODO watch out for double time from EnemyWave

    [SerializeField]
    private int maxEnemiesAllowed; // Maximum number of enemies allowed to be alive at once

    [Header("Autogeneration Attributes")]
    [SerializeField]
    private int nAutogeneratedWaves = 0; // Create n waves automatically

    [SerializeField]
    private List<GameObject> enemiesForAutogeneration; // Randomly select enemies from this list for auto waves

    private int currentWaveIndex; // Index of current wave
    private float spawnTimer; // Timer to check spawn of next enemy in current wave
    private int enemiesAlive; // Number of enemies currently alive
    private int enemiesKilled; // Number of enemies killed
    private int neededEnemyQuota; // Number of killed enemies needed to spawn the boss
    private bool waitingForNextWave = false; // Flag to check if waiting for next wave


    void Awake()
    {
        if (Instance != null)
        {
            Destroy(this.gameObject);
            return;
        }

        Instance = this;
    }

    /// <summary>
    /// Autogenerate waves if nAutogeneratedWaves is set.
    /// Calculate wave quota for each wave.
    /// </summary>
    void Start()
    {
        if (nAutogeneratedWaves != 0)
        {
            this.wavesCopy = GenerateWaves(this.nAutogeneratedWaves);
        }

        wavesCopy = waves.ConvertAll(wave => wave.Clone());

        foreach (EnemyWave wave in wavesCopy)
        {
            if (wave.waveQuota == 0)
                wave.CalculateWaveQuota();
            neededEnemyQuota += wave.waveQuota;
        }

        currentWaveIndex = 0;
        SetProgressionFlag();
    }

    /// <summary>
    /// Spawn enemies from current wave every spawnInterval seconds.
    /// </summary>
    void FixedUpdate()
    {
        if (currentWaveIndex >= wavesCopy.Count)
            return;

        //Check if current wave is finished: if all enemies have been spawned, move to next wave
        if (currentWaveIndex < wavesCopy.Count - 1 && wavesCopy[currentWaveIndex].spawnCount >= wavesCopy[currentWaveIndex].waveQuota && !waitingForNextWave)
        {
            waitingForNextWave = true;
            StartCoroutine(BeginNextWave());
        }

        //Spawn enemies from current wave
        spawnTimer += Time.deltaTime;
        if (spawnTimer >= wavesCopy[currentWaveIndex].spawnInterval)
        {
            spawnTimer = 0;
            SpawnWave(wavesCopy[currentWaveIndex]);
        }

    }

    /// <summary>
    /// Coroutine to start next wave after waveInterval
    /// </summary>
    /// <returns></returns>
    IEnumerator BeginNextWave()
    {
        yield return new WaitForSeconds(waveInterval);

        if (currentWaveIndex < wavesCopy.Count - 1)
        {
            currentWaveIndex++;
            SetProgressionFlag();
            var t = ProgressionManager.Instance.GetRunTime();
            var t2 = ProgressionManager.Instance.CheckStoryFlag(ProgressionManager.StoryFlags.Flag1);
            var t3 = ProgressionManager.Instance.CheckStoryFlag(ProgressionManager.StoryFlags.Flag2);
            spawnTimer = wavesCopy[currentWaveIndex].spawnInterval; // Start spawning immediately
        }
        waitingForNextWave = false;
    }

    /// <summary>
    /// Spawn enemies from current wave: Go through each enemy group and spawn enemies
    /// </summary>
    private void SpawnWave(EnemyWave currentWave)
    {
        if (currentWave.spawnCount < currentWave.waveQuota)
        {
            foreach (EnemyGroup enemyGroup in currentWave.enemyGroups)
            {
                for (int i = 0; i < enemyGroup.spawnIntensity; i++)
                {
                    if (enemyGroup.spawnCount < enemyGroup.enemyCount)
                    {
                        if (enemiesAlive >= maxEnemiesAllowed)
                            return;

                        // calculate a random point around enemySpawnPoint
                        SpawnPoint spawnPoint = currentWave.spawnPoints[Random.Range(0, currentWave.spawnPoints.Count)];
                        Vector3 spawnPosition = new Vector3(Random.Range(spawnPoint.spawnPoint.x - spawnPoint.spawnRadius, spawnPoint.spawnPoint.x + spawnPoint.spawnRadius),
                            spawnPoint.spawnPoint.y,
                            Random.Range(spawnPoint.spawnPoint.z - spawnPoint.spawnRadius, spawnPoint.spawnPoint.z + spawnPoint.spawnRadius));

                        // Spawn enemy
                        GameObject gameObject = ObjectPoolManager.Instance.SpawnObject(enemyGroup.enemyPrefab, spawnPosition, Quaternion.identity, ObjectPoolManager.PoolType.Enemy);

                        EnemyController enemyStats = gameObject.GetComponent<EnemyController>();
                        if (enemyStats != null)
                            enemyStats.Initialize();

                        enemyGroup.spawnCount++;
                        currentWave.spawnCount++;
                        enemiesAlive++;
                    }
                }
            }
        }
    }

    private GameObject GetRandomEnemyPrefab()
    {
        if (enemiesForAutogeneration.Count == 0)
            return null;
        return enemiesForAutogeneration[Random.Range(0, enemiesForAutogeneration.Count)];
    }

    /// <summary>
    /// Generate n waves of renadom enemies.
    /// Each wave has 1 enemy group with 10 * waveNumber enemies and spawns at (0,0,0).
    /// </summary>
    /// <param name="nWaves"></param>
    /// <returns></returns>
    private List<EnemyWave> GenerateWaves(int nWaves)
    {
        List<EnemyWave> waves = new List<EnemyWave>();
        for (int i = 1; i < nWaves + 1; i++)
        {
            EnemyWave wave = ScriptableObject.CreateInstance<EnemyWave>();
            wave.spawnInterval = 1;
            wave.enemyGroups = new List<EnemyGroup>();

            EnemyGroup enemyGroup = new EnemyGroup();
            enemyGroup.enemyCount = 10 * i;
            enemyGroup.spawnIntensity = 5;
            enemyGroup.enemyPrefab = GetRandomEnemyPrefab();
            wave.enemyGroups.Add(enemyGroup);

            SpawnPoint spawnPoint = new SpawnPoint();
            spawnPoint.spawnPoint = new Vector3(0, 0, 0);
            spawnPoint.spawnRadius = 5;
            wave.spawnPoints.Add(spawnPoint);

            waves.Add(wave);
        }


        return waves;
    }

    private void SpawnBoss()
    {
        if (bossWave == null)
        {
            Debug.Log("No boss wave to spawn");
            ProgressionManager.Instance.EndGame();
            return;
        }

        ProgressionManager.Instance.SetStoryFlag(ProgressionManager.StoryFlags.FlagBossSpawned);
        SpawnWave(bossWave);
    }

    public void OnEnemyDied()
    {
        enemiesAlive--;
        enemiesKilled++;

        if (enemiesKilled >= neededEnemyQuota)
        {
            SpawnBoss();
        }
    }

    /// <summary>
    /// Sets the progression flag for the current wave.
    /// </summary>
    private void SetProgressionFlag()
    {
        switch (currentWaveIndex)
        {
            case 0:
                ProgressionManager.Instance.SetStoryFlag(ProgressionManager.StoryFlags.Flag1);
                break;
            case 1:
                ProgressionManager.Instance.SetStoryFlag(ProgressionManager.StoryFlags.Flag2);
                break;
            case 2:
                ProgressionManager.Instance.SetStoryFlag(ProgressionManager.StoryFlags.Flag3);
                break;
            case 3:
                ProgressionManager.Instance.SetStoryFlag(ProgressionManager.StoryFlags.Flag4);
                break;
            case 4:
                ProgressionManager.Instance.SetStoryFlag(ProgressionManager.StoryFlags.Flag5);
                break;
            case 5:
                ProgressionManager.Instance.SetStoryFlag(ProgressionManager.StoryFlags.Flag6);
                break;
            case 6:
                ProgressionManager.Instance.SetStoryFlag(ProgressionManager.StoryFlags.Flag7);
                break;
            case 7:
                ProgressionManager.Instance.SetStoryFlag(ProgressionManager.StoryFlags.Flag8);
                break;
            default:
                break;
        }
    }
}
